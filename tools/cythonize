#!/usr/bin/env python
""" cythonize

Cythonize pyx files into C files as needed.

Usage: cythonize [root_dir]

Default [root_dir] is 'scipy'.

Checks pyx files to see if they have been changed relative to their
corresponding C files.  If they have, then runs cython on these files to
recreate the C files.

The script thinks that the pyx files have changed relative to the C files
by comparing hashes stored in a database file.

Simple script to invoke Cython (and Tempita) on all .pyx (.pyx.in)
files; while waiting for a proper build system. Uses file hashes to
figure out if rebuild is needed.

For now, this script should be run by developers when changing Cython files
only, and the resulting C files checked in, so that end-users (and Python-only
developers) do not get the Cython/Tempita dependencies.

Originally written by Dag Sverre Seljebotn, and copied here from:

https://raw.github.com/dagss/private-scipy-refactor/cythonize/cythonize.py

Note: this script does not check any of the dependent C libraries; it only
operates on the Cython .pyx files.
"""

import os
import sys
import hashlib
import cPickle
import subprocess
from subprocess import Popen, PIPE

HASH_FILE = 'cythonize.dat'
DEFAULT_ROOT = 'scipy'

#
# Rules
#
def process_pyx(fromfile, tofile):
    try:
        import Cython
    except ImportError:
        raise OSError('Cython needs to be installed')
    from Cython.Compiler.Version import version as cython_version
    from distutils.version import LooseVersion

    HAVE_CYTHON_0p14 = LooseVersion(cython_version) >= LooseVersion('0.14')

    if HAVE_CYTHON_0p14:
        opt_str = '--fast-fail'
    else:
        opt_str = ''
    r = subprocess.call(['cython'] + opt_str.split() + ["-o", tofile, fromfile])
    if r != 0:
        raise Exception('Cython failed')

def process_tempita_pyx(fromfile, tofile):
    import tempita
    with file(fromfile) as f:
        tmpl = f.read()
    pyxcontent = tempita.sub(tmpl)
    assert fromfile.endswith('.pyx.in')
    pyxfile = fromfile[:-len('.pyx.in')] + '.pyx'
    with file(pyxfile, 'w') as f:
        f.write(pyxcontent)
    process_pyx(pyxfile, tofile)

rules = {
    # fromext : (toext, function)
    '.pyx' : ('.c', process_pyx),
    '.pyx.in' : ('.c', process_tempita_pyx)
    }
#
# Hash db
#
def load_hashes(filename):
    # Return { filename : (sha1 of input, sha1 of output) }
    if os.path.isfile(filename):
        hashes = {}
        with open(filename, 'rb') as f:
            for line in f:
                filename, inhash, outhash = line.split()
                hashes[filename] = (inhash, outhash)
    else:
        hashes = {}
    return hashes

def save_hashes(hash_db, filename):
    with file(filename, 'wb') as f:
        for key, value in hash_db.items():
            f.write("%s %s %s\n" % (key, value[0], value[1]))

def sha1_of_file(filename):
    h = hashlib.sha1()
    with file(filename) as f:
        h.update(f.read())
    return h.hexdigest()

#
# Main program
#

def get_hash(frompath, topath):
    from_hash = sha1_of_file(frompath)
    to_hash = sha1_of_file(topath) if os.path.exists(topath) else None
    return (from_hash, to_hash)

def process(path, fromfile, tofile, processor_function, hash_db):
    fullfrompath = os.path.join(path, fromfile)
    fulltopath = os.path.join(path, tofile)
    current_hash = get_hash(fullfrompath, fulltopath)
    if current_hash == hash_db.get(fullfrompath, None):
        print '%s has not changed' % fullfrompath
        return

    orig_cwd = os.getcwd()
    try:
        os.chdir(path)
        print 'Processing %s' % fullfrompath
        processor_function(fromfile, tofile)
    finally:
        os.chdir(orig_cwd)
    # changed target file, recompute hash
    current_hash = get_hash(fullfrompath, fulltopath)
    # store hash in db
    hash_db[fullfrompath] = current_hash


def find_process_files(root_dir):
    hash_db = load_hashes(HASH_FILE)
    for cur_dir, dirs, files in os.walk(root_dir):
        for filename in files:
            for fromext, rule in rules.iteritems():
                if filename.endswith(fromext):
                    toext, function = rule
                    fromfile = filename
                    tofile = filename[:-len(fromext)] + toext
                    process(cur_dir, fromfile, tofile, function, hash_db)
                    save_hashes(hash_db, HASH_FILE)

def main():
    try:
        root_dir = sys.argv[1]
    except IndexError:
        root_dir = DEFAULT_ROOT
    find_process_files(root_dir)


if __name__ == '__main__':
    main()
